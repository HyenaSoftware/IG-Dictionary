package com.hyenawarrior.OldNorseGrammar.grammar.nouns

import com.hyenawarrior.OldNorseGrammar.grammar.morphophonology.ProductiveTransforms.{ConsonantAssimilation, SieversLaw, StressShift}
import com.hyenawarrior.OldNorseGrammar.grammar.morphophonology.StemTransform.{FixJAugmentation, FixVAugmentatAfterShortSyllable, FixVAugmentatAfterVelar}
import com.hyenawarrior.OldNorseGrammar.grammar.morphophonology.{U_Umlaut, Umlaut, V_Umlaut}
import com.hyenawarrior.OldNorseGrammar.grammar.nouns.stemclasses.{NounStemClass, StrongStemClassFeminineA2}
import com.hyenawarrior.OldNorseGrammar.grammar.phonology.Vowel.isVowel
import com.hyenawarrior.OldNorseGrammar.grammar.{Syllable, Syllables}

/**
  * Created by HyenaWarrior on 2018.01.31..
  */
case class NounStem(rootStr: String, stemClass: NounStemClass)

object NounStem {

  def from(nounForm: NounForm, stemClass: NounStemClass): NounStem = {

    val indefNounForm = CliticArticle.removeArticle(nounForm, stemClass).getOrElse(nounForm).strRepr

    // undo consonant assimilation
    val consAssimilatedStrs = ConsonantAssimilation invert indefNounForm

    // remove inflectional ending and clitic
    val uninflectedStrs = consAssimilatedStrs
      .map(_ -> nounForm.declension)
      .flatMap {

        case stemClass(ustr) => Some(ustr)
        case _ => None
      }


    // try to continue the process by choosing the first string
    uninflectedStrs.headOption match {

      case Some(uninflectedStr) => extractStemFrom(nounForm, stemClass, uninflectedStr)
      case None =>
        val inflectionalEnding = stemClass inflection nounForm.declension
        throw new RuntimeException(s"Word '${nounForm.strRepr}' doesn't have inflectional ending of $inflectionalEnding.")
    }
  }

  private def extractStemFrom(nounForm: NounForm, stemClass: NounStemClass, uninflectedStr: String): NounStem = {

    /*
      // stem -> form
      kné + um  // add inflection
      knéum     // do stress shift, it doesn't try to modify the 'u', so we have an extra vowel
      knjáum    // which is eliminated here vowel deletion
      knjám

      // form -> stem
	    knjám      // remove inflectional ending by special VD-aware stripSuffix in stemClass()
	    knjá + um  // reverse stress shift, but VD removed the 'u' of 'um'
	    knéa + um  // <!> the last 'a' letter is generated by apply, but not removed by unapply
	    kné + um

	    // desired, but incorrect option: form -> stem
	    knjám    // undo stress shift
	    knéam    // remove inflection by special VD-aware stripSuffix
	      // aargh: a+um > am not possible, as 'a' is non-labial, but á+um > ám is ok, as 'á' is labial, see VD
	    kné + um
     */

    val undoSyncope = uninflectedStr.replace("mn", "min")

    val undoIjRemoval = SieversLaw.restore(undoSyncope).getOrElse(undoSyncope).replace("ij","j")

    // undo stress-shift
    val strBeforeStressShift = undoIjRemoval match {

      case StressShift(str) => str.dropRight(1) // unapply of StressShift doesn't drop the extra vowel of 'j'
      case s => s
    }

    val inflectionalEnding = stemClass inflection nounForm.declension

    lazy val isNonProductiveUmlaut = stemClass.transformationFor(nounForm.declension).contains(U_Umlaut)

    // reverse U-umlaut
    val (stemUnUmlautedStr, optUmlaut) = strBeforeStressShift match {

      case t @ U_Umlaut(s) if t != s =>

        val stemVowel = strBeforeStressShift.find(isVowel).head
        val vowelIsResultOfVaugment = U_Umlaut.targetVowels.filter(_ != 'ǫ').contains(stemVowel.toString)
        val appliedUmlaut = if (vowelIsResultOfVaugment) V_Umlaut else U_Umlaut

        s -> Some(appliedUmlaut)

      // umlaut application comes from a non-productive rule
      case s if isNonProductiveUmlaut => s -> Some(U_Umlaut)

      case s => s -> None
    }

    // https://en.wikipedia.org/wiki/Proto-Germanic_language#Morphology
    // I-mutation was the most important source of vowel alternation, and continued well into the history of the
    // individual daughter languages (although it was either absent or not apparent in Gothic). In Proto-Germanic,
    // only -e- was affected, which was raised by -i- or -j- in the following syllable. Examples are numerous:
    //  ...
    //  Noun endings beginning with -i- in u-stem nouns: dative singular, nominative and genitive plural.
    //  ...
    // The following code fixes the stem vowels of skjǫldr: e.g.: skildir -> *skeldir (plural nominative form)
    val stemStr = if(inflectionalEnding.contains("i") && stemUnUmlautedStr.filter(isVowel).toSeq == Seq('i')) {

      stemUnUmlautedStr.replace("i", "e")

    } else stemUnUmlautedStr

    // if optUmlaut!=None then a semivowel caused a productive umlaut mutation in every form of the noun

    //
    val rootStr = removeThematicVowel(stemStr, stemClass)

    // reverse-SVD should be done here?
    val rootStrJ = (stemClass, rootStr) match {

      case (StrongStemClassFeminineA2, Syllables(Syllable(_, "ey", "", _, _):: Nil)) => rootStr + "j"
      case _ => rootStr
    }

    // undo SVD
    val augmentedRootStr = augment(rootStrJ, optUmlaut)

    // create the noun stem
    NounStem(augmentedRootStr, stemClass)
  }

  // basically it's the reverse SVD
  private def augment(stemStr: String, optUmlaut: Option[Umlaut]): String = (stemStr, optUmlaut) match {

    case (FixJAugmentation(fixedStemStr), _) => fixedStemStr
      // hǫgg- -> haggv-
    case (FixVAugmentatAfterVelar(fixedStemStr), Some(V_Umlaut | U_Umlaut)) => fixedStemStr
    case (FixVAugmentatAfterShortSyllable(fixedStemStr),    Some(V_Umlaut)) => fixedStemStr
    case _ => stemStr
  }

  def fromStrRepr(stemStr: String, stemClass: NounStemClass): NounStem = {

    val rootStr = removeThematicVowel(stemStr, stemClass)

    NounStem(rootStr, stemClass)
  }

  def removeThematicVowel(stemStr: String, stemClass: NounStemClass): String = {

    val thematicVowel = stemClass.thematicVowel.getOrElse("")

    stemStr stripSuffix thematicVowel
  }
}